Details of exploiting stack overflow
A stack overflow occurs when the return address of a function inside a program is overwritten. Its new value is the address of the code that will be executed instead. This is usually done when a user passes malicious input that contains the new address at a very specific offset of the input, to the program. The input is processed as usual by the program - but because its format isn’t verified, it allowed to overwrite much more data than it should have. It hence overwrites the return address of that function to make it point to a new address. At this new address is attacker code that does bad things. When that function returns, it visits the bad address now… and runs the bad code.


EIP or the Instruction Pointer or the register that holds the address of the next instruction it’s going to execute. Every function will end with a RET instruction, that copies the address that the stack pointer (ESP) is pointing to, into EIP. Since the attacker has overwritten EIP with the address of her own code, the RET instruction ends up copying this address into EIP, causing code to be run.

Stack Frame Explanation and Importance
Every function in a program has a stack frame. It’s basically a chunk of memory on the stack that every function uses. It consists of the arguments that are passed to it, the return address it returns to once it finishes running, the local variables it uses and all the other locations it uses while pushing and popping values on and off the stack.
It’s important because it forces a function to operate inside a specific are in memory and doesn’t mess with values that are stored elsewhere, by other functions that have not yet terminated. A classic case to prove its importance, is a buffer overflow - when the attacker breaks out of the stack frame of his function and overwrites some other parts of the stack that he does not have access to.

Heap Overflow Vulnerability/Exploitation
Heap Overflows (CWE-122) are a sub-class of the Buffer Overflow vulnerability that can affect applications written in many programming languages, and the name describes any situation in which the software attempts to move data from one location in memory into a fixed-length buffer allocated on the heap, which is too small to hold the data.

Format String Vulnerability/Exploitation
The Format String exploit occurs when the submitted data of an input string is evaluated as a command by the application. In this way, the attacker could execute code, read the stack, or cause a segmentation fault in the running application, causing new behaviors that could compromise the security or the stability of the system.
To understand the attack, it’s necessary to understand the components that constitute it.
	1.	The Format Function is an ANSI C conversion function, like printf, fprintf, which converts a primitive variable of the programming language into a human-readable string representation.

	2.	The Format String is the argument of the Format Function and is an ASCII Z string which contains text and format parameters, like: printf (“The magic number is: %d\n”, 1911);

	3.	The Format String Parameter, like %x %s defines the type of conversion of the format function.
	The attack could be executed when the application doesn’t properly validate the submitted input.


Examining an unknown binary file:
Safely access the file utilizing a VM that is not connected to the network/internet.
Common utilities for reverse engineering

perform static analysis (anything that you can do without running the binary)
	Strings
	binwalk to check what kind of file
	Hex editors or command file *check the magic bytes to check the type of file. check to make sure the magic bytes match for the (ELF) file to ensure the file is tamper-free
	Ghidra—open the file in Ghidra and get a sense of execution flow, trace the program starting from the main function
	check if the binary is stripped or still has debugging symbols (a compiler can strip debug symbols)
	dynamic analysis (anything done by running the binary)

What if it asks for a password
	has any changes been made to the file system (making new files/reading files)
	does it send any network traffic (use Wireshark)
	S-Trace (utility) to view any syscalls that the binary uses 
	syscalls—interface that exposes kernel functions
	L-Trace (utility) view functions in dynamically loaded libraries and which dynamic functions being used (what kind of dynamic libraries show in dynamic functions—commonly loaded dynamic libraries—libc)
	Run it through GDB(debugger), setting breakpoints, particularly around password input to look for a static string

How to get passed password input—
1.	Brute force using wordlists
2.	Using the debugger at the password breakpoint to look for a static string
3.	Patch out the password check in the binary file (modifying the actual binary. No source code needed) by changing the bytes of the file to nops (stands for no operation)

	Registry snapshots (sysinternals-Windows; no registries in Linux)
	File system snapshots (sysinternals-Windows, I-node monitoring (underlying implementation of Linux file system)
	Debuggers (gdb, windbg, others)
	Understanding of file headers—magic bytes (specific pattern of starting bytes that tell you what kind of file it is)

Binary exploitation
•	Common binary vulnerabilities:
o	buffer overflow-- A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold or when a program attempts to put data in a memory area past a buffer. In this case, a buffer is a sequential section of memory allocated to contain anything from a character string to an array of integers. Writing outside the bounds of a block of allocated memory can corrupt data, crash the program, or cause the execution of malicious code.
Buffer lives (is allocated) on the stack
variables in the same function as the buffer live on the stack
(FIFO on the stack)

what does the stack look like? A stack frame 
railroad track is program
stack is whole train 
stack frame is each function and the variables that live in that function (train car)
buffer lives inside of a stack frame (including the functions and variables) (box inside a train car)
code does not live on the stack (it is in the same city as the railroad, but in another area of the city in a warehouse)
at the end of the stack frame is an address (that points to the next piece of code to run (place in the code warehouse)) ***this is how you use a buffer overflow to implement malicious code by sending it to a different location in the code warehouse. Sending it to any other place than the code warehouse should crash the program. Unless you do black magic

Black magic—
Code warehouse is really boring and malicious code can’t be sent there.
BUT!! On a stack frame (train car) you can build a mini-wearhouse, using shell code.
malicious code 1st then junk then the magic address (beginning of the buffer-a portion of the stack frame (a box in a train car)) 
^^^ this is how shell code works 
shell code lives inside the stack frame inside the buffer

if you can’t use the stack to execute  then >>

	UAF (use after free)-- Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code. 

format string vulnerabilities memory is stored in heap (replacement boxcars/stack frame) banana boxcar is replaced by oranges if items are created/deleted

	GOT (global offset table)-- Role is to point to different parts of code (different locations in the warehouse). Why? Index of all items (dewey decimal system). Program doesn’t know where to go. It specifically points to locations within the dynamically loaded libraries, like libc

	ret2libc-- A "return-to-libc" attack is a computer security attack usually starting with a buffer overflow in which a subroutine return address on a call stack is replaced by an address of a subroutine that is already present in the process executable memory, bypassing the no-execute bit feature (if present) and ridding the attacker of the need to inject their own code. (this is a portal within the code warehouse that points to a “cool place”)
libc is a dynamically loaded libraries…using the portal to look at the dynamically loaded libraries
	One of the ways is to use GOT to access ret2libc
	ROP (return-oriented programming)—a computer security exploit technique that allows an attacker to execute the program code 
	In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine's memory, called "gadgets". Each gadget typically ends in a return instruction and is located in a subroutine within the existing program and/or shared library code. Chained together, these gadgets allow an attacker to perform arbitrary operations on a machine employing defenses that thwart simpler attacks. 

how is this different than just regularly run functions? It allows the attacker to bypass ASLR to go to a specific section code. This takes tiny pieces of the code to piece together malicious code.
Completed puzzle is the program running correctly
mixed puzzle is ROP

when we say return, it uses the next address on the stack, that can be attacker controlled (to hop to the next gadget)

I would probably use ROP to run a execve syscall to execute a shell like binbash
prevent ROP attacks with PIE (Position independent executables)


Mitigation for binary vulnerabilities:
	DEP/NX (Data execution prevention/no execution) -- Data Execution Prevention (DEP) is a security feature that monitors and protects certain pages or regions of memory, preventing them from executing (usually malicious) code. 
When DEP is enabled, all data regions are marked as non-executable by default. 
prevents running any code on the stack

	partial RELRO (GOT comes before all other code) Relocation Read-Only
protects the GOT. Relro moves got to the start of the program to make it difficult access

	Full RELRO (GOT is read only and unchangeable) Full RELRO makes the entire GOT read-only which removes the ability to perform a "GOT overwrite" attack, where the GOT address of a function is overwritten with the location of another function or a ROP gadget an attacker wants to run.

	ASLR (Address Space Layout Randomization) -- In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries. (protects against use after free). Only randomizes libraries and memory, not how the code is laid out. 

How to bypass as an attacker—1. Brute force on a 32bit system, not on 64bit system. 2. Look for stack or heap leak (memory address leak), which tells you where you are on the program. 

	stack canaries-- Stack Canaries are a secret value placed on the stack after every buffer which changes every time the program is started. 
	bypass—brute force or leak

	Position independent executables(PIE)—basically ASLR except for the code sections(moving where the entire block starts).(prevents ROP attack)
	bypass-- leak


	
